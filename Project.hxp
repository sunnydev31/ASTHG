import hxp.*;
import lime.tools.*;

/**
	List of all Features of the engine
**/
enum FeatureFlags {
	MODS_ALLOWED;
	DISCORD_ALLOWED;
	TRANSLATIONS_ALLOWED;
}

class Project extends HXProject {

	static var EXCLUDE_ASSETS:Array<String> = [];
	static var customDefines:Array<String> = [];

	static var AndroidSettings:Dynamic = {
		Icons: {

			/**
				Adaptive icons (Android 8.0+) uses a foreground and background layer to create different shapes
				Adds support for monochrome icons on Android 12+ too, this depends on how you configured the XML files. 
			**/
			Adaptive: true, 

			/**
				A circular version of the icon for devices that use round icons
				OPTIONAL if you are using Adaptive icons
			**/
			HasRound: false
		},

		/**
			Changes the game title to a translatable string (by now).
			Also, you can add more localized strings support
		**/
		LocalizedStrings: true
	};

	static var WindowsSettings:Dynamic = {
		CustomVisuals: false // Doesn't work by now
	}

	public function new() {
		super();

		this.meta.title		= "Unnamed Sonic Game";
		
		/*
			Format: YEAR.MONTH.DAY
			YEAR, MONTH, DAY: Current datetime of the update
		*/
		this.meta.version	= '2025.12.21';

		/*
			Type of build, not number
			Format: TEST, RELEASE, PREVIEW
		*/
		this.meta.buildNumber	= "TEST";
		this.meta.company		= "SunkyDev31";
		this.meta.packageName	= "game.sunkydev.asthg";

		this.app = {
			file: "ASTHG",
			main: "Main",
			preloader: "flixel.system.FlxPreloader",
			path: "export/" + (isBuildFlag("debug") ? "debug"
			: isBuildFlag("final") ? "final" : "release")
		};


		if (isTarget("mobile")) {
			this.window.width = 0;
			this.window.height = 0;
			this.window.fullscreen = true;
		} else {
			this.window.width = 426;
			this.window.height = 228;
		}

		this.window.orientation = Orientation.LANDSCAPE;
		this.window.fps = 60;
		this.window.background = (isBuildFlag("debug")) ? 0xFF00FF : 0x000000;
		this.window.resizable = (isTarget("web") || isTarget("desktop")) ? true : false;

		if (isTarget("web")) EXCLUDE_ASSETS.push("*.ogg");
		else EXCLUDE_ASSETS.push("*.mp3");

		echo("");
		echo('${this.meta.title} v' + this.meta.version +
		(this.meta.buildNumber != null ? ' (build ${this.meta.buildNumber})' : ""));
		echo("-----------------------------------------");
		dotPad("Company", this.meta.company, 24, false);
		dotPad("Package", this.meta.packageName, 24, false);
		dotPad("App file", this.app.file, 24, false);
		echo("-----------------------------------------");

		includeAssets("assets/shared", null, null, EXCLUDE_ASSETS);
		includeAssets("assets/fonts", null);
		includeAssets("assets/locales", null);

		sources.push("source");

		setFlag(MODS_ALLOWED, false); // Polymod dependencies are breaking so it will be disabled by default
		setFlag(DISCORD_ALLOWED, isTarget("cpp"));
		setFlag(TRANSLATIONS_ALLOWED, true);
		echo("-----------------------------------------", true);

		syncDefines();

		if (hasFlag(MODS_ALLOWED))
			includeAssets("mods", null);

		// Adding Haxelibs
		addHaxelib("flixel");
		addHaxelib("flixel-addons");
		addHaxelib("tjson");

		addHaxelib("hxdiscord_rpc", (isTarget("cpp") && hasFlag(DISCORD_ALLOWED)));
		//addHaxelib("hxcpp-debug-server", (isBuildFlag("debug")));

		addHaxelib("polymod", hasFlag(MODS_ALLOWED));
		addHaxelib("firetongue", true); // Do NOT disable this.

		addHaxelib("haxeui-core");
		addHaxelib("haxeui-flixel");

		// Android configs
		if (isAndroid()) {
			addHaxelib("extension-androidtools");
	
			if (AndroidSettings.LocalizedStrings == true) {
				//Change game name to a translatable string
				config.set("android.application", {"android:label": "@string/app_name"});
				config.set("android.activity", {"android:label": "@string/app_name"});
			}
		}

		if (!isBuildFlag("debug")) {
			haxedefs.set("FLX_NO_DEBUG", null);
			haxedefs.set("NAPE_RELEASE_BUILD", null);
		}

		haxedefs.set("FLX_NO_FOCUS_LOST_SCREEN", null);
		haxedefs.set("message.reporting", "pretty");

		// Configure PolyMod
		if (hasFlag(MODS_ALLOWED)) {
			if (isBuildFlag("debug"))
				haxedefs.set("POLYMOD_DEBUG",			true);
			
			haxedefs.set("POLYMOD_API_VERSION_MATCH",	"NONE");
			haxedefs.set("POLYMOD_MOD_METADATA_FILE",	"mod.json");
			haxedefs.set("POLYMOD_MOD_PACK_FILE",		"modpack.txt");
			haxedefs.set("POLYMOD_MOD_ICON_FILE",		"mod.png");
			haxedefs.set("POLYMOD_ROOT_PATH",			"scripts/");
			haxedefs.set("POLYMOD_SCRIPT_EXT",			".hxs");
			haxedefs.set("POLYMOD_SCRIPT_LIBRARY",		"scripts");
		}

		templatePaths.push("_project/templates");
		
		if (isAndroid() && AndroidSettings.Icons.Adaptive == true) {
			/*
				NOTE
				This icons can be a drawable (VectorDrawable/"Android SVG") or an mipmap (Image)
				If you will use mipmaps, check "templates" folder
			*/

			config.set("android.activity", {"android:icon": "@drawable/ic_launcher"});

			if (AndroidSettings.Icons.HasRound == true)
				config.set("android.activity", {"android:roundIcon": "@drawable/ic_launcher_round"});
		} else {
			addIcon("icon",		"png",	8,	true);
			addIcon("icon",		"png",	16,	true);
			addIcon("icon",		"svg"); // Main
		}
	}


	// Platform functions

	function isAndroid() {
		return (this.target == Platform.ANDROID && this.platformType == PlatformType.MOBILE);
	}

	function isIOS() {
		return (this.target == Platform.IOS && this.platformType == PlatformType.MOBILE);
	}

	function isWindows() {
		return (this.target == Platform.WINDOWS && this.platformType == PlatformType.DESKTOP);
	}

	function isLinux() {
		return (this.target == Platform.LINUX && this.platformType == PlatformType.DESKTOP);
	}

	function isMacOS() {
		return (this.target == Platform.MAC && this.platformType == PlatformType.DESKTOP);
	}
	
	/**
		Gets a bool if the project is runnning on the selected platform
		@param key Platform target
	**/
	function isTarget(key:String) {
		switch ((StringTools.replace(key, ' ', '_')).toLowerCase()) { //Added only the ones this game uses
			case "cpp", "hl", "neko": return this.targetFlags.exists(key);
			case "desktop": return this.platformType == PlatformType.DESKTOP;
			case "mobile": return this.platformType == PlatformType.MOBILE;
			case "web": return this.platformType == PlatformType.WEB;
			case "xbox", "xbox1", "xboxone": return this.target == Platform.XBOX1;
			default:
				echo("[isTarget] Unknown value '"+ key +"'", true);
				return false;
		}
	}

	function isBuildFlag(key:String) {
		switch (key.toLowerCase()) {
			case "release": return !this.debug;
			case "debug": return this.debug;
			case "final": return this.targetFlags.exists("final");
			default: trace('[Project.hxp::isBuildFlag] Unknown value \'$key\''); return false;
		}
	}

	function hasFlag(key:Dynamic) {
		var flagKey:String = (Std.isOfType(key, FeatureFlags) ? Type.enumConstructor(key) : Std.string(key));
		return this.defines.exists(flagKey);
	}

	function setFlag(key:Dynamic, value:Dynamic) {
		var flagKey:String = (Std.isOfType(key, FeatureFlags) ? Type.enumConstructor(key) : Std.string(key));

		if (value == null)
			value = false;

		if (!customDefines.contains(flagKey)) //Prevents "key" to be added again
			customDefines.push(flagKey);


		dotPad(flagKey, (value == false)? "false" : "true");
		return this.defines.set(flagKey, Std.string(value));
	}

	function getFlag(key:Dynamic) {
		var flagKey:String = (Std.isOfType(key, FeatureFlags) ? Type.enumConstructor(key) : Std.string(key));
		return this.defines.get(flagKey);
	}

	function syncDefines():Void {
		for (key in customDefines) {
			var value = getFlag(key);
			if (value == null || value == "true") {
				this.haxedefs.set(key, null);
			}
			else if (value != "false") {
				this.haxedefs.set(key, value);
			}
		}
	}

	function addHaxelib(name:String, ?condition:Bool) {
		if (condition == null || condition) {
			this.haxelibs.push(new Haxelib(name));
			dotPad(name, "true");
		} else {
			dotPad(name, "false");
		}
	}

	/**
		Prints a text to the console
		@param value The text to print
		@param debug If true, only prints if the build flag "debug" is enabled
	**/
	function echo(value:String, ?debug:Bool = false) {
		if (debug) {
			if (isBuildFlag("debug"))
				return Sys.println(value);
			else
				return;
		} else { return Sys.println(value); }
	}

	/**
		Adds an icon for the application.
		@param name Filename of the icon
		@param format File extension (`png`, `jpg`, `svg`...), usually `png`
		@param size Icon size to append, `null` will use this icon for all sizes
		@param appendSizeTonName If true, the `size` argument will be added to the icon name, becoming `icon16.png` for example
	**/
	function addIcon(name:String, format:String = "png", ?size:Null<Int>, ?appendSizeToName:Null<Bool> = false) {
		var path:String = "_project/icons/" + name;
		if (size != null && appendSizeToName) path += Std.string(size);
		path += '.$format';

		if (size != null)
			echo('[Icon] Path: $path, Size: Placeholder', true); // A null size is a placeholder for all sizes
		else
			echo('[Icon] Path: $path, Size: $size', true);
		this.icons.push(new Icon(path, size));
	}

	/**
		Prints a beauty log text like "My text......My value"
		@param name Text on the Left
		@param value Text on the Right
		@param width Spacement width
		@param debug Prints only if is a debug target
	**/
	function dotPad(name:String, value:Dynamic, ?width:Int = 30, ?debug:Bool = true) {
		var dots = width - name.length;
		if (dots < 1) dots = 1;

		var padding = StringTools.lpad("", ".", dots);

		echo(name + padding + Std.string(value), debug);
	}
}